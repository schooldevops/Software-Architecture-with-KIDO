# Transactional Outbox pattern

Transactional Outbox Pattern은 마이크로서비스 아키텍처에서 사용되는 비동기 통신 패턴 중 하나입니다. 이 패턴은 상태 변경 사항을 처리하는데 사용되며, 상태 변경 사항을 이벤트 형식으로 저장하여 다른 서비스에 전파합니다.

Transactional Outbox Pattern은 일반적으로 다음과 같은 단계를 거칩니다.

상태 변경을 처리하면서 트랜잭션을 시작합니다.
트랜잭션 커밋 전에 이벤트를 저장할 outbox 테이블에 이벤트를 추가합니다.
트랜잭션 커밋 후에 백그라운드 프로세스가 outbox 테이블을 주시하고, 새로운 이벤트를 발견하면 이를 적절한 대상에 전파합니다.
outbox 테이블에서 이벤트를 삭제합니다.
이러한 패턴을 사용하면 이벤트를 전파할 때마다 다른 서비스에 직접 연결할 필요가 없으므로 시스템의 복잡도가 감소합니다.

대표적인 예로는 카프카, 래빗엠큐(RabbitMQ) 등의 메시지 브로커 시스템이 있습니다.

Transactional Outbox Pattern의 베스트 프랙티스는 다음과 같습니다.

Outbox 테이블과 이벤트를 저장하는 방법은 선택적입니다. 따라서 데이터베이스, 파일, 메모리 또는 다른 저장소를 사용할 수 있습니다.
Outbox 테이블에는 이벤트를 저장할 때마다 고유 ID가 할당되어야 합니다. 이는 이벤트를 중복해서 발생하지 않도록 보장합니다.
이벤트를 전송하는 백그라운드 프로세스는 분산 환경에서 안정적으로 실행되도록 구성되어야 합니다. 예를 들어, 클러스터링 및 스케일링을 지원하고, 다운 타임을 최소화하며, 이벤트 전송 실패를 처리할 수 있어야 합니다.

---------------------------------------------
Transactional Outbox Pattern은 마이크로서비스 아키텍처에서 여러 서비스 간의 데이터 일관성을 보장하기 위해 사용되는 디자인 패턴 중 하나입니다. 이 패턴은 이벤트 기반 아키텍처에서 사용되며, 데이터베이스 트랜잭션 외부에 메시지 큐를 사용하여 데이터의 변경 내용을 다른 서비스에게 전달합니다.

대표적인 예시로는 주문 관리 서비스가 있습니다. 주문이 생성될 때 주문 서비스는 데이터베이스에 해당 주문 정보를 저장하고, 주문 서비스 이외의 다른 서비스들에게 해당 주문 정보에 대한 이벤트를 발행합니다. 이벤트는 메시지 큐에 저장되며, 해당 이벤트를 듣고 있는 서비스들은 이벤트에 대한 처리를 수행합니다. 이 방식으로 데이터베이스 트랜잭션과 메시지 큐의 트랜잭션은 분리되어있기 때문에, 메시지 큐의 장애 또는 다른 이유로 인한 실패가 데이터베이스 트랜잭션을 롤백시키는 일은 없습니다.

Transactional Outbox Pattern의 주요 장점은 데이터 일관성과 결합도를 줄이는 것입니다. 이 패턴을 사용함으로써 데이터베이스 트랜잭션과 메시지 큐의 트랜잭션이 분리되어 데이터 일관성을 보장할 수 있습니다. 또한 서비스 간 결합도를 줄일 수 있으며, 비동기적인 방식으로 서비스 간 통신을 수행함으로써 서비스의 확장성을 높일 수 있습니다.

하지만 이 패턴의 단점으로는 이벤트 발행 후 메시지 큐에 저장하는 과정에서 실패가 발생할 수 있다는 것입니다. 이 경우, 이벤트가 중복으로 발생할 가능성이 있으며, 이를 처리하기 위해 중복 이벤트를 필터링하는 추가적인 처리가 필요합니다. 이 패턴의 베스트 프랙티스로는 메시지 큐를 안정적으로 운영하기 위해 백프레셔와 같은 메시지 큐 관련 기술들을 활용하는 것이 있습니다.

