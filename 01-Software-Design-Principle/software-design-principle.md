# Software Design Principle

- 소프트웨어 디자인 원칙은 SOLIC라고 불리며 이는 (SRP, OCP, LSP, ISP, DIP)의 앞글자를 따서 SOLIC라고 부른다. 
- 디자인 원칙은 견고하고, 확장성이 있으며, 신뢰성, 유지보수성이 뛰어난 어플리케이션을 구현하기 위한 훌륭한 원칙이다. 

## SRP(Single Responsibility Principle)

- SRP(Single Responsibility Principle)는 소프트웨어 디자인 원칙으로 단일 책임 원칙을 말한다.
- 클래스나 모듈은 단 하나의 책임만을 가져야 한다는 것을 의미한다. 
- 모듈의 응집도를 높이고 결합도를 낮추어 유지보수와 확장이 쉬운 구조를 유지할 수 있다.

<br/>

### SRP 베스트프랙티스

- 1. 클래스의 크기를 작게 유지하기
  - 클래스가 담당하는 책임이 많을수록 코드가 복잡해지고 유지보수성이 떨어진다. 
  - 따라서 클래스의 크기를 작게 유지하고, 각 클래스는 특정한 기능에만 집중하도록 설계하는 것이 좋다.
- 2. 인터페이스와 추상화를 활용하기
  - 인터페이스와 추상화를 사용하면, 클래스의 구현과 인터페이스를 분리할 수 있어 책임이 분리된다. 
  - 이를 통해 클래스는 자신이 담당하는 책임에만 집중할 수 있다.
- 3. 단일 책임 클래스를 사용하기
  - 단일 책임 클래스는 오직 하나의 책임만을 갖도록 설계된 클래스이다. 
  - 이를 사용하면 클래스가 담당하는 책임이 분명해지고, 클래스 간의 의존성이 낮아져 결합도가 낮아진다.
- 4. 테스트 가능한 코드 작성하기
  - SRP를 따르면 모듈의 응집도가 높아지므로, 모듈을 테스트하기 쉬워진다. 
  - 따라서 SRP를 따르면 테스트 가능한 코드를 작성할 수 있다.
  - 다시 단일 책임원칙을 따르지 않으면 테스트가 쉽게 깨지고, 이를 재작성하기 위한 방법역시 복잡해진다, 그러므로 테스트코드를 통한 단일 책임원칙 접근법도 좋은 방법이다.

## OCP(Open Close Principle)

- OCP(Open-Closed Principle)는 소프트웨어 디자인 원칙 중 하나로 개방-폐쇄 원칙이라고 한다., 
- 소프트웨어 요소(클래스, 모듈, 함수 등)는 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다는 것을 의미한다. 
- 이를 통해 유지보수성과 재사용성을 높일 수 있다.

### OCP 베스트프랙티스

- 1. 추상화를 사용하기
  - 추상화를 사용하면, 소프트웨어 요소의 변화에 대응하기 쉬워진다.
  - 추상화를 통해 기능을 추상화하고, 인터페이스를 사용하여 각 기능을 분리하면, 새로운 기능을 추가하거나 기존 기능을 수정해도 다른 기능에 영향을 미치지 않는다.
  - 즉, 내부의 변경으로 인해 연관된 타 요소에 영향을 미치지 않도록 구성하는 것이 핵심이다.
- 2. 다형성을 사용하기
  - 다형성은 OCP를 구현하는 데 중요한 개념이다.
  - 다형성을 사용하면, 인터페이스를 구현한 다양한 클래스가 있을 때, 클라이언트 코드는 인터페이스에만 의존하여 변경에 유연하게 대응할 수 있다.
- 3. 팩토리 패턴을 사용하기
  - 팩토리 패턴은 객체 생성을 추상화하여, 클라이언트 코드가 구체적인 객체 생성을 알 필요가 없도록 해준다. 
  - 이를 통해 새로운 객체를 추가하거나 기존 객체를 수정해도 클라이언트 코드를 변경하지 않아도 되므로 OCP를 구현하기에 좋다.
- 4. 의존성 주입(Dependency Injection)을 사용하기
  - 의존성 주입은 객체간의 의존성을 줄이고 유연한 소프트웨어를 만드는데 중요한 이다. 
  - 의존성 주입을 사용하면, 객체를 생성하는 책임을 클라이언트에서 분리하여 객체 생성에 대한 제어를 바깥에서 할 수 있다. 
  - 이를 통해 새로운 객체를 추가하거나 기존 객체를 수정해도 클라이언트 코드를 변경하지 않아도 되므로 OCP를 구현하기에 좋다.

## LSP(Liskov Substitution Principle)

- LSP(Liskov Substitution Principle)는 소프트웨어 디자인 원칙 중 하나로, 리스코프 치환원칙이라고 한다.
- 이는 하위 클래스는 상위 클래스의 대체 가능성을 보장해야 한다는 것을 의미한다. 
- 즉, 상위 클래스의 기능을 하위 클래스에서 모두 수행할 수 있어야 한다는 것이다.

### 베스트프랙티스

- 1. 인터페이스를 사용하기
  - 인터페이스를 사용하면, 상위 클래스와 하위 클래스 간에 공통된 기능을 정의할 수 있다.
  - 이를 통해 상위 클래스와 하위 클래스 간의 대체 가능성을 보장할 수 있다.
- 2. 상속을 사용할 때, 상위 클래스와 하위 클래스 간의 관계를 잘 파악하기
  - 상속은 LSP를 따르기 어렵게 만드는 요인 중 하나이다.
  - 상속을 사용할 때에는, 상위 클래스와 하위 클래스 간의 관계를 명확히 파악하고, 상위 클래스에서 정의한 메서드와 속성을 하위 클래스에서 그대로 사용할 수 있도록 해야 한다.
- 3. 다형성을 사용하기
  - 다형성은 LSP를 구현하는 데 중요한 개념이다.
  - 다형성을 사용하면, 하위 클래스가 상위 클래스의 대체 가능성을 보장하는 동시에, 클라이언트 코드는 상위 클래스나 하위 클래스에 구애받지 않고, 동일한 인터페이스를 사용하여 객체를 다룰 수 있다.
- 4. 테스트를 통해 검증하기
  - LSP를 따르기 위해서는 상위 클래스와 하위 클래스 간의 관계를 명확히 이해하고, 대체 가능성을 보장해야 한다. 
  - 이를 검증하기 위해서는 상위 클래스와 하위 클래스의 동작을 테스트하고, 대체 가능성을 보장하는지 확인해야 한다.

## ISP(nterface Segregation Principle)

- ISP(Interface Segregation Principle) 원칙은 소프트웨어 디자인 원칙 중 하나로, 인터페이스 분리 원칙을 말한다.
- 클라이언트가 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다는 것을 의미한다. 
- 즉, 인터페이스를 작은 단위로 쪼개서, 클라이언트가 필요한 인터페이스만 사용할 수 있도록 해야 한다는 것이다.

### 베스트프랙티스

- 1. 인터페이스를 작은 단위로 쪼개기
  - 인터페이스를 작은 단위로 쪼개면, 클라이언트가 필요한 인터페이스만 사용할 수 있도록 해준다. 
  - 이를 통해 인터페이스 간의 결합도를 낮출 수 있다.
- 2. 클라이언트에게 필요한 기능만 포함된 인터페이스를 정의하기
  - 클라이언트가 사용하지 않는 기능이 포함된 인터페이스를 사용하면, 클라이언트는 필요하지 않은 기능에 의존하게 된다. 
  - 따라서 클라이언트에게 필요한 기능만 포함된 인터페이스를 정의해야 한다.
- 3. 인터페이스 별로 다른 구현체를 사용하기
  - ISP를 따르면, 인터페이스를 작은 단위로 쪼갤 수 있다. 
  - 이 때, 인터페이스별로 다른 구현체를 사용하면, 클라이언트는 필요한 인터페이스만 사용할 수 있으며, 불필요한 인터페이스에 의존하지 않아도 된다
- 4. 인터페이스에 필요한 기능만 포함하기
  - ISP를 따르면, 인터페이스를 작은 단위로 쪼갤 수 있다. 
  - 이 때, 인터페이스에는 필요한 기능만 포함해야 한다. 
  - 즉, 불필요한 기능이나 구현 세부사항 등은 인터페이스에서 제외해야 한다.

## DIP(Dependency Inversion Primciple)

- DIP(Dependency Inversion Principle) 원칙은 소프트웨어 디자인 원칙 중 하나로, 의존성 역전 원칙이라고 부른다. 
- 고수준 모듈이 저수준 모듈에 의존하지 않도록 하고, 추상화에 의존하도록 해야 한다는 것을 의미한다.
- 즉, 추상화를 통해 모듈 간의 의존성을 최소화하고, 유연한 소프트웨어를 만들어야 한다는 것이다.

### 베스트프랙티스

- 1. 추상화를 사용하기
  - DIP를 따르기 위해서는 추상화를 사용해야 한다.
  - 추상화는 인터페이스나 추상 클래스를 사용하여 구현을 추상화하는 것을 의미한다.
- 2. 추상화를 통해 저수준 모듈과의 의존성을 최소화하기
  - 고수준 모듈은 저수준 모듈에 의존하지 않아야 하며, 추상화를 통해 저수준 모듈과의 의존성을 최소화해야 한다.
- 3. 추상화된 인터페이스나 추상 클래스를 상속받아 구체적인 클래스를 작성하기
  - DIP를 따르기 위해서는 구체적인 클래스가 추상화된 인터페이스나 추상 클래스를 상속받아 작성되어야 한다.
- 4. 의존성 주입(Dependency Injection) 사용하기
  - DIP를 따르기 위해서는 의존성 주입을 사용해야 한다.
  - 의존성 주입은 객체를 생성하는 시점에서 해당 객체가 필요로 하는 의존성을 외부에서 주입하는 방식이다.
- 5. 의존성 최소화 하기
  - 모듈 간의 의존성을 최소화하고, 유연하고 확장 가능한 소프트웨어를 만들 수 있디. 
  - 유닛 테스트가 용이해지며, 코드의 재사용성과 유지보수성도 향상된다.

## WRADP UP

- SOLID는 소프트웨어 디자인의 다섯 가지 기본 원칙을 의미한다.
  - SRP(Single Responsibility Principle) : 단일 책임 원칙
  - OCP(Open-Closed Principle) : 개방-폐쇄 원칙
  - LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
  - ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
  - DIP(Dependency Inversion Principle) : 의존 역전 원칙
- SOLID 원칙을 지키면 여러가지 장점을 얻을 수 있다.
  - 1. 유연성
    - SOLID는 유지보수성과 확장성을 높이는 데 도움이 되며, 변경에 대한 유연성을 제공한다.
  - 2. 코드의 재사용성
    - SOLID는 모듈 간의 결합도를 낮추고, 모듈 간의 의존성을 최소화하여 코드의 재사용성을 높인다.
  - 3. 유지보수성
    - SOLID는 코드의 복잡성을 낮추어 유지보수성을 높인다.
  - 4. 테스트 용이성
    - SOLID는 단위 테스트를 용이하게 하며, 이는 소프트웨어의 품질을 높이는 데 도움이 된다.
  - 5. 협업 용이성
    - SOLID는 코드를 이해하기 쉽고, 이해하기 쉬운 코드는 다른 개발자들과의 협업을 용이하게 만든다.

- SOLID를 지키는 것은 소프트웨어의 품질과 유지보수성을 높이는 데 큰 도움이 됩니다.
