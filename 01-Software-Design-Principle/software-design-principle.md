# Software Design Principle

- 소프트웨어 디자인 원칙은 SOLID라고 불리며 Robert C.Martin이 주창한 원칙이다.
- 이는 (SRP, OCP, LSP, ISP, DIP)의 앞글자를 따서 SOLID라고 부른다. 
- 디자인 원칙은 견고하고, 확장성이 있으며, 신뢰성, 유지보수성이 뛰어난 어플리케이션을 구현하기 위한 훌륭한 원칙이다. 

## SRP(Single Responsibility Principle)

- SRP(Single Responsibility Principle)는 소프트웨어 디자인 원칙으로 단일 책임 원칙으로 해석된다.
- 클래스나 모듈은 단 하나의 책임만을 가져야 한다는 것을 의미한다. 
- 모듈의 응집도를 높이고 결합도를 낮추어 유지보수와 확장이 쉬운 구조를 유지할 수 있다.
- 책임: 
  - 특정 사용자의 요청을 처리해야하는 책임으로 이해

<br/>

- clean architecture 에서 단일책임 원칙 정의
  - ```A module should have one, and only one, reason to change.``` 
    - 모듈은 변경되어야 할 오직 한가지의 변경 사유만 있어야한다.
  - ```A module should be responsible to one, and only one, user or stakeholder.``` 
    - 모듈은 사용자 혹은 스테이크홀더(이해관계자)에게만 책임을 져야한다.
  - ```A module should be responsible to one, and only one, actor.```
    - 모듈은 오직 하나의 액터에 의해서만 책임을 저야한다. 
- 응집도라는 용어는 SRP를 포함한다. 즉, 단일 액터만을 책임지기 위해서 서로 응집되어 있어야한다. 
- 콘웨이의 법칙 생각해보기
  - 콘웨이는 ```소프트웨어 아키텍처는 조직의 의사소통 구조에 따라 결정된다.``` 라고 했다. 
  - 조직의 사회적 구조에 따라 소프트웨어 아키텍처가 영향을 받기 때문에, 각 모듈 혹은 서비스는 변경해야할 단 하나의 이유를 가진다. 
### 단일 책임 원칙을 위배한 예제

- 골프연습장 멤버에 대한 아키텍팅을 수행하고자 하는 경우를 가정해보자.

```java
class Member {
  String name;
  Integer age;
  String joinDate;

  String getName() {...}
  Integer getAge() {...}
  ...
  
  Integer getUseBallCount() {...}
  List<Score> getGameScores() {...}
}
```

- 위 케이스는 회원과 회원의 활동 정보가 동일한 클래스 내에 존재 
- 회원의 가입정보, 회원의 활동정보가 서로다른 액터의 책임을 공동으로 가지고 있음

<br/>

### 솔루션 

```java
class Member {
  String name;
  Integer age;
  String joinDate;

  String getName() {...}
  Integer getAge() {...}
  ...
}

class MemberPracticesAnalizer {
  Member member;

  Integer getUseBallCount() {...}
  SwingPath getSwingPathLog() {...}
}

class MemberGameAnalizer {
  Member member;

  List<Score> getGameScores() {...}
}
```

- 위 클래스는 멤버, 연습 분석기, 게임분석기 3개의 클로스로 분리하여 SRP를 준수한다. 
- Member 클래스는 회원 정보만을 관리한다. 
- MemberPracticesAnalizer 클래스는 멤버가 수행한 연습 정보를 저장/조회/분석한다. 
- MemberGameAnalizer 클래스는 멤버가 수행한 게임 기록을 관리한다. 
- 각각 클래스는 액터의 요청에 따라 책임을 분리하였다. 

<br/>

### 솔루션 2: 통합된 정보를 한번에 관리가 필요한경우

```java
class MemberFacade {
  Member getMembeById() {}
  Integer getUseBallCountByMemberId(Long id) {}
  SwingPath getSwingPathLogByMemberId(Long id) {}
  List<Score> getGameScoresByMemberAndGameId(Long id, Long gameNo) {}
}
```

- SRP를 지키다 보면 책임으로 분리된 여러 클래스를 조합해서 결과를 반환하거나 액션을 수행해야할 수 있다. 
- 이 경우 Facade 패턴으로 이러한 문제를 해결하면서도 SRP를 지킬 수 있다. 
- ```Facade```는 프랑스 어로 ```대문``` 이라는 의미이며 액터에게 내부 구현은 감추고, 수행가능한 인터페이스만 열어주는 기능을 수행한다. 

### SRP 베스트프랙티스

- 1. 클래스의 크기를 작게 유지하기
  - 클래스가 담당하는 책임이 많을수록 코드가 복잡해지고 유지보수성이 떨어진다. 
  - 따라서 클래스의 크기를 작게 유지하고, 각 클래스는 특정한 기능에만 집중하도록 설계하는 것이 좋다.
- 2. 인터페이스와 추상화를 활용하기
  - 인터페이스와 추상화를 사용하면, 클래스의 구현과 인터페이스를 분리할 수 있어 책임이 분리된다. 
  - 이를 통해 클래스는 자신이 담당하는 책임에만 집중할 수 있다.
- 3. 단일 책임 클래스를 사용하기
  - 단일 책임 클래스는 오직 하나의 책임만을 갖도록 설계된 클래스이다. 
  - 이를 사용하면 클래스가 담당하는 책임이 분명해지고, 클래스 간의 의존성이 낮아져 결합도가 낮아진다.
- 4. 테스트 가능한 코드 작성하기
  - SRP를 따르면 모듈의 응집도가 높아지므로, 모듈을 테스트하기 쉬워진다. 
  - 따라서 SRP를 따르면 테스트 가능한 코드를 작성할 수 있다.
  - 다시 단일 책임원칙을 따르지 않으면 테스트가 쉽게 깨지고, 이를 재작성하기 위한 방법역시 복잡해진다, 그러므로 테스트코드를 통한 단일 책임원칙 접근법도 좋은 방법이다.

### SRP(Single Responsibility Principle)의 주요 장점

#### 높은 응집성

- 응집도(Cohesion)는 책임 즉 동일한 책임을 수행하는 데이터와 기능을 하나로 묶어주는 것
- SRP는 클래스와 메소드에 단일 책임을 할당하므로 응집성을 높일 수 있다. 
- 각 클래스와 메소드가 한 가지 기능만 담당하면 클래스와 메소드 내부의 코드는 연관성이 높아지며, 서로 다른 기능을 가진 코드가 뒤섞이지 않아 코드의 가독성과 유지보수성이 향상된다.

#### 낮은 결합도

- 결합도(Coupling)는 하나의 기능이 여러가지 일을 수행하는 정도를 나타낸다. 
- 이때 여러가지 일이란 것은 단일책임영역에 속하지 않는 다른 영역의 일역시 여기저기서 수행하여, 특정 코드의 변경에 따른 사이드 이펙트가 높아지는 현상을 야기한다. 
- SRP는 코드를 책임에 따라 나누기 때문에 클래스와 메소드 간의 결합도가 낮아진다. 
- 즉, 하나의 클래스나 메소드를 변경할 때 다른 클래스와 메소드에 영향을 미치지 않는다. 
- 이는 유연한 코드를 작성할 수 있게 한다.

#### 코드의 재사용성

- SRP는 클래스와 메소드에 책임을 분배하므로 코드의 재사용성이 높아진다. 
- 즉, 단일 책임 원칙을 따르는 클래스와 메소드는 다른 프로젝트에서도 재사용될 수 있다.

#### 유지보수성

- SRP는 코드를 작은 단위로 쪼개서 구현하므로 유지보수성이 높아진다. 
- 각 클래스와 메소드는 명확한 책임을 가지므로 코드 변경이 필요한 경우 해당 책임만 수정하면 된다. 
- 이는 다른 기능에 대한 영향을 최소화하면서 코드를 변경할 수 있게 해준다.

<br/>

- 따라서 SRP를 따르면 코드의 가독성, 유지보수성, 재사용성, 유연성 등이 향상되며, 코드의 결합도와 복잡도를 줄일 수 있다.
- 이는 클래스 설계 뿐만 아니라, 마이크로 서비스, 서비스 기반 아키텍처 등에서도 SRP는 매우 중요한 설계 원칙이다. 

-------------------------

## OCP(Open Close Principle)

- OCP(Open-Closed Principle)는 소프트웨어 디자인 원칙 중 하나로 개방-폐쇄 원칙이라고 한다., 
- 1988년 Bertrand Meyer이 주창한 원칙이다. 
- ```A software artifact should be open for extension but closed for modification.``` 
  - 소프트웨어 요소(클래스, 모듈, 함수 등)는 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다는 것을 의미한다. 
- 확장: 
  - 어플리케이션의 기능을 추가하는 것
  - 열린다는 개념: 기능을 추가하여도 기존 시스템에 영향을 주지 않는다. 
- 변경: 
  - 존재하는 기능의 변경을 수행하는 것
  - 닫혀있다는 개념: 변경이 발생하여도 참조하는 기능이나 어플리케이션에 영향을 주게 된다. 가능하면 변경보다는 확장을 하도록 해야한다.
- 이를 통해 유지보수성과 재사용성을 높일 수 있다.
- 클래스나 메소드에 적용이 되지만, 소프트웨어 아키텍처 컴포넌트 레벨이나, 서비스 레벨에도 적용된다. 

### OCP 원칙을 위배한 예제

```java
class Pet{
  String petType;
  void speak() {
    if ("Dog".equals(petType)) {
      System.out.println("Bark");
    } else if ("Cat".equals(petType)) {
      System.out.println("Miou");
    }
  }
}
```

- Pet 클래스에서 petType에 따라 speak() 함수에서 조건식을 검사하고 있다. 
- 이경우 새로운 Pet이 추가되면 관련 조건문 전체를 수정해야하며, 누락되거나 이를통해 사이드 이펙이 발생할 가능성이 높아진다. 

### 솔루션 

```java
interface Pet {
  void speak();
}

class Cat implements Pet {
  void speak() {
    System.out.println("Miou");
  }
}

class Dog implements Pet {
  void speak() {
    System.out.println("Bark");
  }
}

class SuperDog extends Dog {
  @Override
  void speak() {
    System.out.println("Bark! Bark! Bark! Bark! Bark! Bark! Bark!");
  }
}

class GroomingPet {
  void grooming(List<Pet> pets) {
    for (Pet pet in pets) {
      pet.speak();
    }
  }
}
```

- 위 코드 패턴은 새로운 종류의 Pet이 필요한경우, Pet을 구현한 class를 추가하기만 하면 되므로 확장에 열려있다.
- grooming에 어떠한 변경도 발생하지 않으며, 사이드 이펙도 발생하지 않는다. 변경에는 닫혀있다. 
- 특히 SuperDog과 같이 기존 클래스를 상속 받는 경우에도 메소드 오버라이딩을 통해서 확장이 가능하다. 

### OCP 베스트프랙티스

- 1. 추상화를 사용하기
  - 추상화를 사용하면, 소프트웨어 요소의 변화에 대응하기 쉬워진다.
  - 추상화를 통해 기능을 추상화하고, 인터페이스를 사용하여 각 기능을 분리하면, 새로운 기능을 추가하거나 기존 기능을 수정해도 다른 기능에 영향을 미치지 않는다.
  - 즉, 내부의 변경으로 인해 연관된 타 요소에 영향을 미치지 않도록 구성하는 것이 핵심이다.
- 2. 다형성을 사용하기
  - 다형성은 OCP를 구현하는 데 중요한 개념이다.
  - 다형성을 사용하면, 인터페이스를 구현한 다양한 클래스가 있을 때, 클라이언트 코드는 인터페이스에만 의존하여 변경에 유연하게 대응할 수 있다.
- 3. 팩토리 패턴을 사용하기
  - 팩토리 패턴은 객체 생성을 추상화하여, 클라이언트 코드가 구체적인 객체 생성을 알 필요가 없도록 해준다. 
  - 이를 통해 새로운 객체를 추가하거나 기존 객체를 수정해도 클라이언트 코드를 변경하지 않아도 되므로 OCP를 구현하기에 좋다.
- 4. 의존성 주입(Dependency Injection)을 사용하기
  - 의존성 주입은 객체간의 의존성을 줄이고 유연한 소프트웨어를 만드는데 중요한 이다. 
  - 의존성 주입을 사용하면, 객체를 생성하는 책임을 클라이언트에서 분리하여 객체 생성에 대한 제어를 바깥에서 할 수 있다. 
  - 이를 통해 새로운 객체를 추가하거나 기존 객체를 수정해도 클라이언트 코드를 변경하지 않아도 되므로 OCP를 구현하기에 좋다.

### OCP의 장점 

- 확장성: 
  - 새로운 기능이나 요구 사항이 추가되어도 기존 코드를 수정할 필요 없이, 기존 코드를 확장하여 새로운 동작을 추가할 수 있다. 
  - 이는 코드의 재사용성과 유지 보수성을 높여준다.
- 안정성: 
  - 변경으로 인한 파급 효과를 줄일 수 있다. 
  - 변경에 따른 영향을 최소화하여 시스템의 안정성을 유지할 수 있다.
- 유연성: 
  - 기존 코드를 수정하지 않아도 새로운 동작을 추가할 수 있으므로, 시스템의 유연성이 높아진다. 
  - 새로운 기능이나 요구 사항이 추가될 때, 기존 코드를 수정하지 않아도 되므로 시스템의 대응력이 높아진다.
- 단순성:
  - 개방-폐쇄 원칙이 지켜지므로, 코드의 복잡도를 낮출 수 있다. 
  - 새로운 요구 사항이나 기능이 추가될 때마다 코드를 수정하는 것이 아니므로, 코드의 복잡도가 낮아져 가독성과 이해성이 높아진다.

## LSP(Liskov Substitution Principle)

- LSP(Liskov Substitution Principle)는 소프트웨어 디자인 원칙 중 하나로, 리스코프 치환원칙이라고 한다.
- 이는 하위 클래스는 상위 클래스의 대체 가능성을 보장해야 한다는 것을 의미한다. 
- 즉, 상위 클래스의 기능을 하위 클래스에서 모두 수행할 수 있어야 한다는 것이다.

### 베스트프랙티스

- 1. 인터페이스를 사용하기
  - 인터페이스를 사용하면, 상위 클래스와 하위 클래스 간에 공통된 기능을 정의할 수 있다.
  - 이를 통해 상위 클래스와 하위 클래스 간의 대체 가능성을 보장할 수 있다.
- 2. 상속을 사용할 때, 상위 클래스와 하위 클래스 간의 관계를 잘 파악하기
  - 상속은 LSP를 따르기 어렵게 만드는 요인 중 하나이다.
  - 상속을 사용할 때에는, 상위 클래스와 하위 클래스 간의 관계를 명확히 파악하고, 상위 클래스에서 정의한 메서드와 속성을 하위 클래스에서 그대로 사용할 수 있도록 해야 한다.
- 3. 다형성을 사용하기
  - 다형성은 LSP를 구현하는 데 중요한 개념이다.
  - 다형성을 사용하면, 하위 클래스가 상위 클래스의 대체 가능성을 보장하는 동시에, 클라이언트 코드는 상위 클래스나 하위 클래스에 구애받지 않고, 동일한 인터페이스를 사용하여 객체를 다룰 수 있다.
- 4. 테스트를 통해 검증하기
  - LSP를 따르기 위해서는 상위 클래스와 하위 클래스 간의 관계를 명확히 이해하고, 대체 가능성을 보장해야 한다. 
  - 이를 검증하기 위해서는 상위 클래스와 하위 클래스의 동작을 테스트하고, 대체 가능성을 보장하는지 확인해야 한다.

## ISP(nterface Segregation Principle)

- ISP(Interface Segregation Principle) 원칙은 소프트웨어 디자인 원칙 중 하나로, 인터페이스 분리 원칙을 말한다.
- 클라이언트가 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다는 것을 의미한다. 
- 즉, 인터페이스를 작은 단위로 쪼개서, 클라이언트가 필요한 인터페이스만 사용할 수 있도록 해야 한다는 것이다.

### 베스트프랙티스

- 1. 인터페이스를 작은 단위로 쪼개기
  - 인터페이스를 작은 단위로 쪼개면, 클라이언트가 필요한 인터페이스만 사용할 수 있도록 해준다. 
  - 이를 통해 인터페이스 간의 결합도를 낮출 수 있다.
- 2. 클라이언트에게 필요한 기능만 포함된 인터페이스를 정의하기
  - 클라이언트가 사용하지 않는 기능이 포함된 인터페이스를 사용하면, 클라이언트는 필요하지 않은 기능에 의존하게 된다. 
  - 따라서 클라이언트에게 필요한 기능만 포함된 인터페이스를 정의해야 한다.
- 3. 인터페이스 별로 다른 구현체를 사용하기
  - ISP를 따르면, 인터페이스를 작은 단위로 쪼갤 수 있다. 
  - 이 때, 인터페이스별로 다른 구현체를 사용하면, 클라이언트는 필요한 인터페이스만 사용할 수 있으며, 불필요한 인터페이스에 의존하지 않아도 된다
- 4. 인터페이스에 필요한 기능만 포함하기
  - ISP를 따르면, 인터페이스를 작은 단위로 쪼갤 수 있다. 
  - 이 때, 인터페이스에는 필요한 기능만 포함해야 한다. 
  - 즉, 불필요한 기능이나 구현 세부사항 등은 인터페이스에서 제외해야 한다.

## DIP(Dependency Inversion Primciple)

- DIP(Dependency Inversion Principle) 원칙은 소프트웨어 디자인 원칙 중 하나로, 의존성 역전 원칙이라고 부른다. 
- 고수준 모듈이 저수준 모듈에 의존하지 않도록 하고, 추상화에 의존하도록 해야 한다는 것을 의미한다.
- 즉, 추상화를 통해 모듈 간의 의존성을 최소화하고, 유연한 소프트웨어를 만들어야 한다는 것이다.

### 베스트프랙티스

- 1. 추상화를 사용하기
  - DIP를 따르기 위해서는 추상화를 사용해야 한다.
  - 추상화는 인터페이스나 추상 클래스를 사용하여 구현을 추상화하는 것을 의미한다.
- 2. 추상화를 통해 저수준 모듈과의 의존성을 최소화하기
  - 고수준 모듈은 저수준 모듈에 의존하지 않아야 하며, 추상화를 통해 저수준 모듈과의 의존성을 최소화해야 한다.
- 3. 추상화된 인터페이스나 추상 클래스를 상속받아 구체적인 클래스를 작성하기
  - DIP를 따르기 위해서는 구체적인 클래스가 추상화된 인터페이스나 추상 클래스를 상속받아 작성되어야 한다.
- 4. 의존성 주입(Dependency Injection) 사용하기
  - DIP를 따르기 위해서는 의존성 주입을 사용해야 한다.
  - 의존성 주입은 객체를 생성하는 시점에서 해당 객체가 필요로 하는 의존성을 외부에서 주입하는 방식이다.
- 5. 의존성 최소화 하기
  - 모듈 간의 의존성을 최소화하고, 유연하고 확장 가능한 소프트웨어를 만들 수 있디. 
  - 유닛 테스트가 용이해지며, 코드의 재사용성과 유지보수성도 향상된다.

## WrapUp

- SOLID는 소프트웨어 디자인의 다섯 가지 기본 원칙을 의미한다.
  - SRP(Single Responsibility Principle) : 단일 책임 원칙
  - OCP(Open-Closed Principle) : 개방-폐쇄 원칙
  - LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
  - ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
  - DIP(Dependency Inversion Principle) : 의존 역전 원칙
- SOLID 원칙을 지키면 여러가지 장점을 얻을 수 있다.
  - 1. 유연성
    - SOLID는 유지보수성과 확장성을 높이는 데 도움이 되며, 변경에 대한 유연성을 제공한다.
  - 2. 코드의 재사용성
    - SOLID는 모듈 간의 결합도를 낮추고, 모듈 간의 의존성을 최소화하여 코드의 재사용성을 높인다.
  - 3. 유지보수성
    - SOLID는 코드의 복잡성을 낮추어 유지보수성을 높인다.
  - 4. 테스트 용이성
    - SOLID는 단위 테스트를 용이하게 하며, 이는 소프트웨어의 품질을 높이는 데 도움이 된다.
  - 5. 협업 용이성
    - SOLID는 코드를 이해하기 쉽고, 이해하기 쉬운 코드는 다른 개발자들과의 협업을 용이하게 만든다.

- SOLID를 지키는 것은 소프트웨어의 품질과 유지보수성을 높이는 데 큰 도움이 됩니다.
